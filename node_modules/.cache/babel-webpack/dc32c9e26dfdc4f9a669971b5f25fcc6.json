{"ast":null,"code":"import { InjectionToken } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, queueScheduler, asyncScheduler } from 'rxjs';\nimport { subscribeOn, observeOn, tap } from 'rxjs/operators';\nexport const RealtimeDatabaseURL = new InjectionToken('angularfire2.realtimeDatabaseURL');\nexport const DATABASE_URL = RealtimeDatabaseURL;\n\nfunction noop() {}\n\nexport class ɵZoneScheduler {\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n\n  now() {\n    return this.delegate.now();\n  }\n\n  schedule(work, delay, state) {\n    const targetZone = this.zone;\n\n    const workInZone = function (state) {\n      targetZone.runGuarded(() => {\n        work.apply(this, [state]);\n      });\n    };\n\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n\n}\nexport class ɵBlockUntilFirstOperator {\n  constructor(zone) {\n    this.zone = zone;\n    this.task = null;\n  }\n\n  call(subscriber, source) {\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n    return source.pipe(tap(unscheduleTask, unscheduleTask, unscheduleTask)).subscribe(subscriber).add(unscheduleTask);\n  }\n\n  unscheduleTask() {\n    if (this.task != null && this.task.state === 'scheduled') {\n      this.task.invoke();\n      this.task = null;\n    }\n  }\n\n}\nexport class ɵAngularFireSchedulers {\n  constructor(ngZone) {\n    this.ngZone = ngZone;\n    this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n    this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n  }\n\n}\nexport function ɵkeepUnstableUntilFirstFactory(schedulers, platformId) {\n  return function keepUnstableUntilFirst(obs$) {\n    if (isPlatformServer(platformId)) {\n      obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n    }\n\n    return obs$.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n  };\n}\nexport const runOutsideAngular = zone => obs$ => {\n  return new Observable(subscriber => {\n    return zone.runOutsideAngular(() => {\n      runInZone(zone)(obs$).subscribe(subscriber);\n    });\n  });\n};\nexport const runInZone = zone => obs$ => {\n  return new Observable(subscriber => {\n    return obs$.subscribe(value => zone.run(() => subscriber.next(value)), error => zone.run(() => subscriber.error(error)), () => zone.run(() => subscriber.complete()));\n  });\n};\nexport class FirebaseZoneScheduler {\n  constructor(zone, platformId) {\n    this.zone = zone;\n    this.platformId = platformId;\n  }\n\n  schedule(...args) {\n    return this.zone.runGuarded(function () {\n      return queueScheduler.schedule.apply(queueScheduler, args);\n    });\n  }\n\n  keepUnstableUntilFirst(obs$) {\n    if (isPlatformServer(this.platformId)) {\n      return new Observable(subscriber => {\n        const noop = () => {};\n\n        const task = Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\n        obs$.subscribe(next => {\n          if (task.state === 'scheduled') {\n            task.invoke();\n          }\n\n          ;\n          subscriber.next(next);\n        }, error => {\n          if (task.state === 'scheduled') {\n            task.invoke();\n          }\n\n          subscriber.error(error);\n        }, () => {\n          if (task.state === 'scheduled') {\n            task.invoke();\n          }\n\n          subscriber.complete();\n        });\n      });\n    } else {\n      return obs$;\n    }\n  }\n\n  runOutsideAngular(obs$) {\n    return new Observable(subscriber => {\n      return this.zone.runOutsideAngular(() => {\n        return obs$.subscribe(value => this.zone.run(() => subscriber.next(value)), error => this.zone.run(() => subscriber.error(error)), () => this.zone.run(() => subscriber.complete()));\n      });\n    });\n  }\n\n}\nconst noopFunctions = ['ngOnDestroy'];\nexport const ɵlazySDKProxy = (klass, observable, zone) => {\n  return new Proxy(klass, {\n    get: (_, name) => zone.runOutsideAngular(() => {\n      if (klass[name]) {\n        return klass[name];\n      }\n\n      if (noopFunctions.includes(name)) {\n        return () => {};\n      }\n\n      let promise = observable.toPromise().then(mod => {\n        const ret = mod && mod[name];\n\n        if (typeof ret == 'function') {\n          return ret.bind(mod);\n        } else if (ret && ret.then) {\n          return ret.then(res => zone.run(() => res));\n        } else {\n          return zone.run(() => ret);\n        }\n      });\n      return new Proxy(() => undefined, {\n        get: (_, name) => promise[name],\n        apply: (self, _, args) => promise.then(it => it && it(...args))\n      });\n    })\n  });\n};","map":{"version":3,"sources":["C:/Users/cristian/OneDrive/Documentos/bitbucket/puntocomercios/node_modules/@angular/fire/__ivy_ngcc__/es2015/angularfire2.js"],"names":["InjectionToken","isPlatformServer","Observable","queueScheduler","asyncScheduler","subscribeOn","observeOn","tap","RealtimeDatabaseURL","DATABASE_URL","noop","ɵZoneScheduler","constructor","zone","delegate","now","schedule","work","delay","state","targetZone","workInZone","runGuarded","apply","ɵBlockUntilFirstOperator","task","call","subscriber","source","unscheduleTask","bind","run","Zone","current","scheduleMacroTask","pipe","subscribe","add","invoke","ɵAngularFireSchedulers","ngZone","outsideAngular","runOutsideAngular","insideAngular","ɵkeepUnstableUntilFirstFactory","schedulers","platformId","keepUnstableUntilFirst","obs$","lift","runInZone","value","next","error","complete","FirebaseZoneScheduler","args","noopFunctions","ɵlazySDKProxy","klass","observable","Proxy","get","_","name","includes","promise","toPromise","then","mod","ret","res","undefined","self","it"],"mappings":"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","sourcesContent":["import { InjectionToken } from '@angular/core';\r\nimport { isPlatformServer } from '@angular/common';\r\nimport { Observable, queueScheduler, asyncScheduler } from 'rxjs';\r\nimport { subscribeOn, observeOn, tap } from 'rxjs/operators';\r\nexport const RealtimeDatabaseURL = new InjectionToken('angularfire2.realtimeDatabaseURL');\r\nexport const DATABASE_URL = RealtimeDatabaseURL;\r\nfunction noop() { }\r\nexport class ɵZoneScheduler {\r\n    constructor(zone, delegate = queueScheduler) {\r\n        this.zone = zone;\r\n        this.delegate = delegate;\r\n    }\r\n    now() {\r\n        return this.delegate.now();\r\n    }\r\n    schedule(work, delay, state) {\r\n        const targetZone = this.zone;\r\n        const workInZone = function (state) {\r\n            targetZone.runGuarded(() => {\r\n                work.apply(this, [state]);\r\n            });\r\n        };\r\n        return this.delegate.schedule(workInZone, delay, state);\r\n    }\r\n}\r\nexport class ɵBlockUntilFirstOperator {\r\n    constructor(zone) {\r\n        this.zone = zone;\r\n        this.task = null;\r\n    }\r\n    call(subscriber, source) {\r\n        const unscheduleTask = this.unscheduleTask.bind(this);\r\n        this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\r\n        return source.pipe(tap(unscheduleTask, unscheduleTask, unscheduleTask)).subscribe(subscriber).add(unscheduleTask);\r\n    }\r\n    unscheduleTask() {\r\n        if (this.task != null && this.task.state === 'scheduled') {\r\n            this.task.invoke();\r\n            this.task = null;\r\n        }\r\n    }\r\n}\r\nexport class ɵAngularFireSchedulers {\r\n    constructor(ngZone) {\r\n        this.ngZone = ngZone;\r\n        this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\r\n        this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\r\n    }\r\n}\r\nexport function ɵkeepUnstableUntilFirstFactory(schedulers, platformId) {\r\n    return function keepUnstableUntilFirst(obs$) {\r\n        if (isPlatformServer(platformId)) {\r\n            obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\r\n        }\r\n        return obs$.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\r\n    };\r\n}\r\nexport const runOutsideAngular = (zone) => (obs$) => {\r\n    return new Observable(subscriber => {\r\n        return zone.runOutsideAngular(() => {\r\n            runInZone(zone)(obs$).subscribe(subscriber);\r\n        });\r\n    });\r\n};\r\nexport const runInZone = (zone) => (obs$) => {\r\n    return new Observable(subscriber => {\r\n        return obs$.subscribe(value => zone.run(() => subscriber.next(value)), error => zone.run(() => subscriber.error(error)), () => zone.run(() => subscriber.complete()));\r\n    });\r\n};\r\nexport class FirebaseZoneScheduler {\r\n    constructor(zone, platformId) {\r\n        this.zone = zone;\r\n        this.platformId = platformId;\r\n    }\r\n    schedule(...args) {\r\n        return this.zone.runGuarded(function () { return queueScheduler.schedule.apply(queueScheduler, args); });\r\n    }\r\n    keepUnstableUntilFirst(obs$) {\r\n        if (isPlatformServer(this.platformId)) {\r\n            return new Observable(subscriber => {\r\n                const noop = () => { };\r\n                const task = Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\r\n                obs$.subscribe(next => {\r\n                    if (task.state === 'scheduled') {\r\n                        task.invoke();\r\n                    }\r\n                    ;\r\n                    subscriber.next(next);\r\n                }, error => {\r\n                    if (task.state === 'scheduled') {\r\n                        task.invoke();\r\n                    }\r\n                    subscriber.error(error);\r\n                }, () => {\r\n                    if (task.state === 'scheduled') {\r\n                        task.invoke();\r\n                    }\r\n                    subscriber.complete();\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            return obs$;\r\n        }\r\n    }\r\n    runOutsideAngular(obs$) {\r\n        return new Observable(subscriber => {\r\n            return this.zone.runOutsideAngular(() => {\r\n                return obs$.subscribe(value => this.zone.run(() => subscriber.next(value)), error => this.zone.run(() => subscriber.error(error)), () => this.zone.run(() => subscriber.complete()));\r\n            });\r\n        });\r\n    }\r\n}\r\nconst noopFunctions = ['ngOnDestroy'];\r\nexport const ɵlazySDKProxy = (klass, observable, zone) => {\r\n    return new Proxy(klass, {\r\n        get: (_, name) => zone.runOutsideAngular(() => {\r\n            if (klass[name]) {\r\n                return klass[name];\r\n            }\r\n            if (noopFunctions.includes(name)) {\r\n                return () => { };\r\n            }\r\n            let promise = observable.toPromise().then(mod => {\r\n                const ret = mod && mod[name];\r\n                if (typeof ret == 'function') {\r\n                    return ret.bind(mod);\r\n                }\r\n                else if (ret && ret.then) {\r\n                    return ret.then((res) => zone.run(() => res));\r\n                }\r\n                else {\r\n                    return zone.run(() => ret);\r\n                }\r\n            });\r\n            return new Proxy(() => undefined, {\r\n                get: (_, name) => promise[name],\r\n                apply: (self, _, args) => promise.then(it => it && it(...args))\r\n            });\r\n        })\r\n    });\r\n};\r\n"]},"metadata":{},"sourceType":"module"}